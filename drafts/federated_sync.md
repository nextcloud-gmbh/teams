**Version 1.0.0 - 08/05/22 13:29**

- comments on this version:
    * it might not be necessary to have a random key string generated as `itemId`; `itemId` can be
      auto-incremented,
    * a use-case where data are de-sync between `Circles` and an app using this feature (ie. app failing
      to fulfill the destruction of a remote share when requested) is fixed by adding a `deleted`
      field/entry to `circles_item`. When an `item` is in the process of deletion, the entry related
      to `itemId` in `circles_item` is flag as `deleted` and will only be deleted from the table when
      the `IFederatedSyncManager` returns `ItemNotFoundException` on `serializeItem(itemId)`. No action
      can be initiated on an `item` flag as `deleted`

# Federated Sync

The concept of **Federated Sync** is to provide enough tools for an app to share its own content over
multiple instances of Nextcloud.

We call `item` a chunk of data identified by a unique id which represent an entry that can be shared.

> If we take the Deck App as example, an `item` is a board with attached cards and comments. A user can
> create a board and share it. Recipients to the share have access to the board, cards and comments.

The data of a shared `item` is copied in the database of every instances that host at least one `User`
whom is a member of the circles the `item` is shared to.

To implements **Federated Sync**, the app must comply to some prerequisites:

- Create a class that implements [`IFederatedSyncManager`](../lib/IFederatedSyncManager.php),
- Use [`CircleSharesManager`](../lib/ICircleSharesManager.php) to notify `Circles` when creating or
  altering a share or an item.

_Note:_ the current sync does not support `partial update`, which can be implemented in the future with
a `IFederatedPartialSyncManager` that will add few methods to the `IFederatedSyncManager`.

### Known limits

`Circles` allow the creating of circles over instances not necessarily available to each others as long
as the master instance of the circle (the instance the owner of the circle belongs to) can reach every
other instances.  
However, sharing will require direct exchange with other instances from the instance the `item` have been
created.

**A shared item will only be available between 2 instances if both instances are known to each other** (
cf. `./occ circles:remote`)

_In case of a circle grouping internal and external instances, the only solution will come from the
users: the shared item must be created on the same instance the owner of the circle belongs to._

# Implementing in an app

The app need to register a _Federated Sync Manager_:

```
class Application extends App implements IBootstrap {
    public function boot(IBootContext $context): void {
		/** @var CirclesManager $circleManager */
		$circleManager = $context->getAppContainer()->get(CirclesManager::class);
		$circleManager->getShareManager()
					  ->registerFederatedSyncManager(TestFederatedSync::class);
    }
}
```

`TestFederatedSync` is a local class that implements `IFederatedSyncManager` which will be used
by `Circles` to communicate with the app

### Full Support or Lazy Implementation ?

As we will see, the concept of **Federated Sync** requires the app to register a `IFederatedSyncManager`
able to:

- `syncItem(itemId, serializeData);` create/update item based on serializedData
- `serializeItem(itemId): array;` serialize an item based on itemId
- `deleteItem(itemId);` delete item based on itemId
- `isShareCreatable(itemId, circleId, extraData, membership): bool;` confirm a share can be generated by
  this member
- `onShareCreation(itemId, circleId, extraData, membership)` create a new share
- `isShareModifiable(itemId, circleId, &extraData, membership)` confirm a share can be edited by this
  member
- `onShareModification(itemId, circleId, extraData, membership)` update a share
- `isShareDeletable(itemId, circleId, extraData, membership): bool;` confirm a share can be deleted by
  this member
- `onShareDeletion(itemId, circleId, memberships)` delete a share
- `isItemUpdatable(itemId, &serializedData, federatedUser): bool;` confirm an item is modifiable by this
  user
- `updateItem(itemId, extraData, federatedUser)`
  and the app to use `ICircleSharesManager` when:

- a share is created using `createShare(itemId, circleId, extraData)`
- a share is updated using `updateShare(itemId, circleId, extraData)`
- a share is deleted using `deleteShare(itemId, circleId, extraData)`
- an item is updated using `updateItem(itemId, extraDataData)`
- an item is deleted using `deleteItem(itemId)`

If is possible that the code used when doing most of those action might already exist in the external
app, and this code is called directly by the `Controller` as direct interaction with the front-end.

We can assume that the code is structured as:

- first, _verification of the feasibility of the action_,
- second, _proceed to the requested action_.

When implementing **Federated Sync**, it is considered **FullSupport** to move all the code into the
generated `IFederatedSyncManager` and call the right methods from `ICircleSharesManager` at the right
time. Each process will run the same on every instance of the circle.

The **LazyImplementation** is to keep the current code, and only notify `Circles` after the legacy code
of the app is done In that case, some method from `IFederatedSyncManager` related to the action to be
performed will not be run on the instance that initiate the action.

>     For a better understanding, and with the example of the Deck App, this is a quick overview of creating a new share
>     In FullSupport:
>      * user create a new share,
>      * Deck's controller calls `createShare()` from `Circles`
>      * `Circles` run `isShareCreatable()`
>      * `Circles run `onShareCreation()` on every instance
>
>     In LazyImplementation:
>      * user create a new share,
>      * Deck's controller confirm creation and fill the database or throw Exception if not possible
>      * Deck calls `createShare()` from `Circles`
>      * Circles run `isShareCreatable()`
>      * Circles run `onShareCreation()` on every instance but the one that initiate the process

While it is fully advice to use the **FullSupport**, both implementation should safely work on Single
Instance and GlobalScale.

# Database, tables

`circles_item`:

- **id**
- **single_id**
- **instance**
- **app_id**
- **item_type**
- **item_id**
- **checksum**

- `single_id` and `item_id` are each unique.
- `checksum` is a checksum of the current content of the shared item. It is used to compare version on
  sync.
- `item_id` is `varchar(32)` and must be filled with a random string generated by the app. The app must
  also store this `item_id` in the related table.

`circles_share`:

- **id**
- **single_id**
- **circle_id**

- [`single_id`, `circle_id`] is a unique key pair

`circles_lock`:

- **id**
- **single_id**
- **update_type**
- **update_type_id**
- **time**

- [`single_id`, `update_type`, `update_type_id`] is a unique key pair

# Basic Knowledge about the Circles App

quick reminder on the technology used by `Circles` that will be used in the process

### IEntity and SingleId

`Circles` allows to identify an entity from the instance by a _unique single id_, making sharing simpler
as the same table and code can be used for a share to a user or to a grouping of accounts.

### Signed request

When `Circles` from `instance1` is requesting `instance2`, the payload is signed using a private/public
key pairs, available through `/.well-known/webfinger`. Meaning that:

- `instance2` can confirm the origin of the request as `instance1`,
- `instance1` can request a proof of ownership on the key pair when requesting `/.well-known/webfinger`.

### IFederatedItem

`IFederatedItem` is an existing process to exchange data related to a circle, making the master instance
of the circle (the one the owner of the circle belongs to) to be requested when running any operation on
a circle (example: add, edit, remove members). Once an operation is confirmed by master instance, every
other instances from the circle will be requested to run the exact same creation/modification process.

This technology will be used by **Federated Sync** to broadcast some event to every instance of a circle.
However, the data itself will only be exchanged by direct request to the instance that host the
original `item` from each other instances.

# Proof of concept, Analysis

Draft of how **Federated Sync** should handle each sharing action while providing safe exchange of the
data:

- `instanceX` describe the Circles App on Nextcloud number X,
- `userXY` is a user on Nextcloud number X,
- `circleX` is a circle owned by a user from Nextcloud number X,
- `appX` is the app on Nextcloud number X,

In this draft, the step-by-step description of each process will be displayed in a table with 3 columns
that represent 3 different instances of Nextcloud named `Nextcloud 1`, `Nextcloud 2`,`Nextcloud 3`. The
flow of the process must be read from top to bottom.

### New item, new share.

This process describe:

- the process of sharing a new item,
- the process of sharing an existing item already shared to another circle.
- the process of resharing a local item.

Nextcloud 1 | Nextcloud 2 | Nextcloud 3
---|---|---
| | `user2` is owner of `circle2` |
| `user1` is member of `circle2` | | `user3` is member of `circle2`
| |
| `user1` share `item1` |
| `app1` calls `createShare(itemId, circleId, extraData): void;` |
| `instance1` verify `itemId` already exists in `circles_item`. If it does, compare with `appId`, `itemType`, extract `itemSingleId` and see if `instance` is local. (see `Action: Sharing a non-local item`)
| if `itemSingleId` is known, search for existing shares in `circles_share` based on `itemSingleId`, `circleId`.
| `instance1` get membership based on current session `FederatedUser`, `circleId` and request `app1` to verify share can be created using `isShareCreatable(itemId, circleId, extraData, Membership): bool;`
|`app1` confirms the share is creatable.
| if `itemSingleId` is not known, `instance1` generate a new one and created tne entry in `circles_item` using `itemSingleId`, `instance` (local), `appId`, `itemType`, `itemId`
| `instance1` creates an entry in `circles_share` using `itemSingleId` and `circleId`
| if `fullSupport`, `instance1` uses `onShareCreation(itemId, circleId, extraData, Membership): void;`and `app1` generate entries in its own shares table.
| `instance1` create a `IFederatedItem` using `circleId` containing `itemSingleId`, `appId`, `itemType`, `itemId` and request the master instance for `circle2`
| |
| _Async process at this point._
| |
| | as master instance for `circle2`, `instance2` receive the `IFederatedItem`.
| | `instance2` verify `itemSingleId` exists in `circles_item`. If it does, compare with `appId`, `itemType`, `itemId` and confirm `instance`=`instance1`.
| | if `itemSingleId` is not known, create a new entry in `circles_item`.
| | `instance2` request all instances available in `circle2` and broadcast the `IFederatedItem`
| `instance1` will ignore the request | `instance2` will run the exact same process than `instance3` | `instance3` verify `itemSingleId` exists in `circles_item`. If it does, compare with `appId`, `itemType`, `itemId` and confirm `instance`=`instance1`.
| | | `instance3` send a signed request to `instance1` to retrieve content of the shared item, based on `itemSingleId`, `appId`, `itemType`, `itemId`, `circleId`.
| `instance1` confirms at least one user from `instance3` belongs to one of the circles `itemSingleId` is shared to using `circles_share`
| `instance1` returns serialized data of the item using `serializeItem(itemId)`, and its checksum.
| | | if `itemSingleId` was not known, and after confirmation from `instance1`, store data in `circles_item`.
| | | if `itemSingleId` was known, `instance3` compare `checksum`. If different to the one stored in `circles_item`, use `syncItem(itemId, serializedData): void;` and update `checksum`
| | | `app3` get serialized data and store it in its own table.
| | | `instance3` search for existing shares in `circles_share` based on `itemSingleId`, `circleId`. exit process if found.
| | | `instance3` store data in `circles_share`
| | | `instance3` communicate the new share to `app3` using `onShareCreation(itemId, circleId, extraData)`
| | | `app3` generate/update an entry in its own shares table

### Sharing a non-local item

This process describe:

- the process of sharing a remote item,
- the process of sharing a local item

We can assume that re-sharing is creating a share on an `item` that does not belong to the `initiator` of
the request.

Nextcloud 1 | Nextcloud 2 | Nextcloud 3
---|---|---
| | `user2` is owner of `circle2` |
| `user1` is member of `circle2` | | `user3` is member of `circle2`
| | `user2` is owner of `circle2b`
| `user1` is member of `circle2b` | | `user3` is member of `circle2b`
| `user1` share `item1` to `circle2` with `permissions`
| | | `user3` share `item1` to `circle2b`
| | | `app3` calls `createShare(itemId, circleId, extraData): void;`
| | | `instance3` get `itemSingleId` from `circles_item`, based on `appId`, `itemType`, `itemId` see that `instance` is not local. (for local, see `Action: New item, new share`)
| | | `instance3`  search for existing shares in `circles_share` based on `itemSingleId`, `circleId`.
| | | `instance3` request `instance1` about the new share using `itemSingleId`, `circleId`, `extraData`, `FederatedUser` (current session)
| `instance1` confirm `itemSingleId` exists in `circles_item` and `instance` is `instance1`. get `appId`, `itemType`, `itemId`
| `instance1` confirms `FederatedUser` is known and `instance` is `instance3` and belongs to one of the circle `itemSingleId` is shared to in `circles_share`.
| `instance1` get membership based on `FederatedUser`, `circleId` and request `app1` to verify share can be created using `isShareCreatable(itemId, circleId, extraData, Membership): bool;`
|`app1` confirms the share is creatable, based on other memberships of `initiator` that can be extract from `Membership` and its `FederatedUser` to verify permissions
| `instance1` creates an entry in `circles_share` using `itemSingleId` and `circleId`
| `instance1` uses `onShareCreation(itemId, circleId, extraData, Membership): void;` and `app1` generate entries in its own shares table.
| `instance1` create a `IFederatedItem` using `circleId` containing `itemSingleId`, `appId`, `itemType`, `itemId` and request the master instance for `circle2b`
| |
| _Async process at this point._
| | | `instance1` confirmed the creation of the share and `instance3` will create an entry in `circles_share` and if no conflict run `onShareCreation(itemId, circleId, extraData)`.
| |
| | as master instance for `circle2b`, `instance2` receive the `IFederatedItem`.
| | `instance2` verify `itemSingleId` exists in `circles_item`. If it does, compare with `appId`, `itemType`, `itemId` and confirm `instance`=`instance1`.
| | if `itemSingleId` is not known, create a new entry in `circles_item`.
| | `instance2` request all instances available in `circle2b` and broadcast the `IFederatedItem`
| `instance1` will ignore the request | `instance2` verify `itemSingleId` exists in `circles_item`. If it does, compare with `appId`, `itemType`, `itemId` and confirm `instance`=`instance1`. | `instance3` will realise that share already exist in `circles_share`
| | `instance2` send a signed request to `instance1` to retrieve content of the shared item, based on `itemSingleId`, `appId`, `itemType`, `itemId`, `circleId`.
| `instance1` confirms at least one user from `instance3` belongs to one of the circles `itemSingleId` is shared to using `circles_share`
| `instance1` returns serialized data of the item using `serializeItem(itemId)`, and its checksum.
| | if `itemSingleId` was not known, and after confirmation from `instance1`, store data in `circles_item`.
| | if `itemSingleId` was known, `instance2` compare `checksum`. If different to the one stored in `circles_item`, use `syncItem(itemId, serializedData): void;` and update `checksum`
| | `app2` get serialized data and store it in its own table.
| | `instance2` search for existing shares in `circles_share` based on `itemSingleId`, `circleId`. exit process if found.
| | `instance2` store data in `circles_share`
| | `instance2` communicate the new share to `app2` using `onShareCreation(itemId, circleId, extraData)`
| | `app2` generate/update an entry in its own shares table

### Edit shares permissions

This process describe:

- the process of update a local share,
- the process of update a remote share.

Nextcloud 1 | Nextcloud 2 | Nextcloud 3
---|---|---
| | `user2` is owner of `circle2` |
| `user1` is member of `circle2` | | `user3` is member of `circle2`
| |
| `user1` share `item1` |
| | | `user3` update the share of `item1` to `circle2`
| | | `app3` uses `$circleManager->getShareManager(appId, itemType)->updateShare(itemId, circleId, extraData): void;`
| | | `instance3` get `itemSingleId` from `circles_item` and get remote host from `instance`.
| | | (in case the process was initiated from `Nextcloud1` the `instance would be local and the process goes directly to step `(b)`)
| | | `instance3` request `instance1` about the update using `itemSingleId`, `circleId`, `extraData`, `FederatedUser` (current session)
|`instance1` confirms `itemSingleId` exist in `circles_item` and `instance` is local
| `instance1` confirms at least one user from `instance3` belongs to one of the circle to which the item have been shared to using `circles_share`
|`instance1` confirms `FederatedUser` exist, is from `instance3` and belongs to one of the circle.
|`instance1` ask `app1` if share can be edited using `isShareModifiable(itemId, circleId, extraData, FederatedUser): bool;`
|`app1` confirm permission and rights based on the memberships of `FederatedUser`.
| `instance1` communicate the updated share to `app1` using `onShareModification(itemId, circleId, extraData)`
| `instance1` create a FederatedItem using `circleId` containing `shareSindleId`, `extraData`
| |
| _Async process at this point._
| | | if update was initiated from `instance3`, `instance1` confirmed the update and `instance3` run `onShareModification(itemId, circleId, extraData)`
| |
| | as master instance for `circle2`, `instance2` receive the `IFederatedItem`.
| | `instance2` verify `itemSingleId` exists in `circles_item`. If it does, compare with `appId`, `itemType`, `itemId` and confirm `instance`=`instance1`.
| | if `itemSingleId` is not known, create a new entry in `circles_item`.
| | `instance2` request all instances available in `circle2` and broadcast the `IFederatedItem`
| `instance1` will ignore the request | `instance2` verify `itemSingleId` exists in `circles_item`. If it does, compare with `appId`, `itemType`, `itemId` and confirm `instance`=`instance1`. | if update was initiated from `instance3`, `instance3` will ignore the request. If not, will run exactly like `instance2`
| | `instance2` confirm the share exist in `circles_share`.
| | `instance2` use onShareModification(itemId, circleId, extraData)
| | `app2` update the share in its own table.

### Updating an item

This process describe:

- updating a local item or one of its components,
- updating a non-local item or one of its components.

**UpdateLock**

To avoid race condition, `UpdateLock` allows the app to lock any further update on an item during a
previous update process. The app have the possibility to lock specific entry of the item.

The `UpdateLock` will identify the locked part using `updateType` and `updateTypeId`

> In case of the Deck App, it is possible to lock the action of moving a card (`updateType='card'`, `updateTypeId=cardId`) while not locking
> the edition of another card (`updateType='card'`, `updateTypeId=anotherCardId`)

The `UpdateLock` also allow the app to enforce that the `item` (stored on the instance a user initiated
the update) is the last known version.

Now, because most of the locks will only be kept few 1/10s, any parallel request will cycle for few
seconds, waiting for an available slot, before returning a lock error.  
A `fifo` can be implemented in the future if needed.

**Updating an item**

Nextcloud 1 | Nextcloud 2 | Nextcloud 3
---|---|---
| `user1` is owner of `circle1` |
| | | `user3` is member of `circle1`
| | `user2` is owner of `circle2`
| `user1` is member of `circle2`
| |
| `user1` shares `item1` to `circle1`
| `user1` shares `item1` to `circle2`
| | | `user3` update `item1`. Based on the edit, `app3` generate an `updateLock` based on `updateType`, `updateTypeId` and if `checksum` needs to be up-to-date.
| | | `app3` calls `updateItem(itemId, extraData, updateLock): void;`
| | | `instance3` get `itemSingleId`, `checksum` from `circles_item` linked to `appId`, `itemType`, `itemId` and get remote host from `instance`
| | | `instance3` request `instance1` about the update using `itemSingleId`, `extraData`, `updateLock`, `FederatedUser` (current session), `checksum`
| `instance1` confirms `itemSingleId` exist and get `checksum` in `circles_item` and `instance` is local
| `instance1` confirms at least one user from `instance3` belongs to one of the circle to which the item have been shared to using `circles_share`
| `instance1` confirm `FederatedUser` exist in local database, is from `instance3` and belongs to one of the circle.
| `(a)` if `updateLock.verifyChecksum` is `true`, `instance1` confirm `checksum` from `circles_item` is identical to the one sent by `instance3`
| `instance1` search in `circles_lock` for a lock using `updateLock.updateType`, `updateLock.updateTypeId`
| if the `UpdateLock` is older than a minute, the entry is ignored and deleted. | if an `UpdateLock` exists, pause for a second. Retrieve `checksum` from `circles_item` and return to the previous step `(a)`
| `instance1` will wait for the `item` to `unlock` for few seconds and returns a SyncException if the lock is still up.
| `instance1` use `isItemUpdatable(itemId, extraData, federatedUser): bool;`
| `app1` confirm permissions to update based on `extraData`, `federatedUser`.
| Async process at this point with the confirmation (or not) that `app1` accepted the update. If accepted, the current `checksum` is also returned
| `instance1` generate an entry in `circles_lock` using `updateLock.updateType`, `updateLock.updateTypeId` and set `time` to now | | if `checksum` from `circles_item` is still the same  and `updateLock.verifyChecksum=false`, or `checksum` is the one returned by `instance1`, then `instance3` initiate the update process locally using `onItemUpdate(itemId, extraData, federatedUser);`
| `instance1` initiate the updating process using `onItemUpdate(itemId, extraData, federatedUser);` | | `app3` update the item in its table.
| `app1` update the item in its table. | | `instance1` get serializedData from `app1` using `serializeItem(itemId)` and update `checksum` in `circles_item`
| `instance1` remove `UpdateLock` from `circles_lock`
| `instance1` get serializedData from `app1` using `serializeItem(itemId)` and update `checksum` in `circles_item`
| based on `circles_share`, `instance1` create one `IFederatedItem` per `circleId`, containing `itemSindleId`, `checksum`:
| _(need to verify if process can be run without a new async)_
| `instance1` will manage `circle1` the same way `instance2` handle `circle2` | `instance2` get `itemId` from `circles_item` linked to `itemSingleId` in `circles_item` and confirm that `instance` is `instance1` and `circleId` is in `circles_share`
| | `instance2` broadcast the FederatedItem to all instances available in the circle
| `instance1` will exit process | | `instance2` will run the exact same process than `instance3` | `instance3` get `itemId` from linked to `itemSingleId` in `circles_item` and `circleId` from `circles_share`
| | | `instance3` verify `checksum` and if the same exit process | | | `instance3` send a signed request to `instance1` to retrieve content of the shared item, based on `itemSingleId`
| `instance1` confirms at least one user from `instance3` belongs to one of the circle to which the item have been shared to using `circles_share`
| `instance1` get serialized data of the item using `serializeItem(itemId): array;`
| `app1` returns serialized data based on `itemId`.
| `instance1` generate a `checksum`, update the one stored in `circles_item` if needed, and returns `serializedData` and `checksum`
| | | `instance3` compare `checksum` with the one in `circles_item`. If different, run `syncItem(itemId, serializedData)`;
| | | `app3` update the item in its table.

### Delete share

not documented yet but will work like `Edit shares permissions`

### Remove item

not documented yet, but will work more or less like `Update Item`

### temp

[comment]: <> (| `instance1` communicate the updated item to `app1`)

[comment]: <> (using `IFederatedSyncManager::syncItem&#40;itemId, serializeData&#41;`)

[comment]: <> (-------------------------)

[comment]: <> (------------------------------)

[comment]: <> (| `instance1` verify `itemId` already exists in `circles_item`. If it does, compare with `appId`)

[comment]: <> (, `itemType`, extract `itemSingleId` and see if `instance` is local. &#40;)

[comment]: <> (see `Action: Resharing a non-local item`&#41;)

[comment]: <> (| if `itemSingleId` is known, search for existing shares in `circles_share` based on `itemSingleId`)

[comment]: <> (, `circleId`. | `instance1` get membership based on current session `FederatedUser`, `circleId` and)

[comment]: <> (request `app1` to verify share can be created)

[comment]: <> (using `isShareCreatable&#40;itemId, circleId, extraData, Membership&#41;: bool;`)

[comment]: <> (|`app1` confirms the share is creatable. | if `itemSingleId` is not known, `instance1` generate a new one)

[comment]: <> (and created tne entry in `circles_item` using `itemSingleId`, `instance` &#40;local&#41;, `appId`, `itemType`)

[comment]: <> (, `itemId`)

[comment]: <> (| `instance1` creates an entry in `circles_share` using `itemSingleId` and `circleId`)

[comment]: <> (| if `fullSupport`, `instance1` uses `onShareCreation&#40;itemId, circleId, extraData, Membership&#41;: void;`)

[comment]: <> (and `app1` generate entries in its own shares table. | `instance1` create a `IFederatedItem`)

[comment]: <> (using `circleId` containing `itemSingleId`, `appId`, `itemType`, `itemId` and request the master instance)

[comment]: <> (for `circle2`)

[comment]: <> (| | | _Async process at this point._)

[comment]: <> (| | | | as master instance for `circle2`, `instance2` receive the `IFederatedItem`. | | `instance2`)

[comment]: <> (verify `itemSingleId` exists in `circles_item`. If it does, compare with `appId`, `itemType`, `itemId`)

[comment]: <> (and confirm `instance`=`instance1`. | | if `itemSingleId` is not known, create a new entry)

[comment]: <> (in `circles_item`. | | `instance2` request **all instances** available in `circle2` to send and broadcast)

[comment]: <> (the `IFederatedItem`)

[comment]: <> (| `instance1` will ignore the request | `instance2` will run the exact same process than `instance3`)

[comment]: <> (| `instance3` verify `itemSingleId` exists in `circles_item`. If it does, compare with `appId`)

[comment]: <> (, `itemType`, `itemId` and confirm `instance`=`instance1`. | | | `instance3` send a signed request)

[comment]: <> (to `instance1` to retrieve content of the shared item, based on `itemSingleId`, `appId`, `itemType`)

[comment]: <> (, `itemId`, `circleId`. | `instance1` confirms at least one user from `instance3` belongs to one of the)

[comment]: <> (circles `itemSingleId` is shared to using `circles_share`)

[comment]: <> (| `instance1` returns serialized data of the item using `serializeItem&#40;itemId&#41;`, and its checksum. | | |)

[comment]: <> (if `itemSingleId` was not known, and after confirmation from `instance1`, store data in `circles_item`. |)

[comment]: <> (| | if `itemSingleId` was known, `instance3` compare `checksum`. If different to the one stored)

[comment]: <> (in `circles_item`, use `syncItem&#40;itemId, serializedData&#41;: void;` and update `checksum`)

[comment]: <> (| | | `app3` get serialized data and store it in its own table. | | | `instance3` search for existing)

[comment]: <> (shares in `circles_share` based on `itemSingleId`, `circleId`. exit process if found. | | | `instance3`)

[comment]: <> (store data in `circles_share`)

[comment]: <> (| | | `instance3` communicate the new share to `app3`)

[comment]: <> (using `onShareCreation&#40;itemId, circleId, extraData&#41;`)

[comment]: <> (| | | `app3` generate/update an entry in its own shares table)

